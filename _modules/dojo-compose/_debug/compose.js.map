{"version":3,"file":"compose.js","sourceRoot":"","sources":["compose.ts"],"names":[],"mappings":"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","sourcesContent":["import WeakMap from 'dojo-core/WeakMap';\nimport {\n\tbefore as aspectBefore,\n\tafter as aspectAfter,\n\taround as aspectAround,\n\tBeforeAdvice,\n\tAfterAdvice,\n\tAroundAdvice\n} from './aspect';\n\n/* A weakmap that will store initialization functions for compose constructors */\nconst initFnMap = new WeakMap<Function, ComposeInitializationFunction<any, any>[]>();\n\n/**\n * A helper funtion to return a function that is rebased\n * @param  {Function} fn The function to be rebased\n * @return {Function}    The rebased function\n */\nfunction rebase(fn: Function): Function {\n   return function(...args: any[]) {\n\t   return fn.apply(this, [ this ].concat(args));\n   };\n}\n\n/**\n * A helper function that copies own properties and their descriptors\n * from one or more sources to a target object. Includes non-enumerable properties\n */\nfunction copyProperties(target: {}, ...sources: {}[]) {\n  sources.forEach(source => {\n    Object.defineProperties(\n\t\ttarget,\n\t\tObject.getOwnPropertyNames(source).reduce(\n\t\t\t(descriptors: { [ index: string ]: any }, key: string) => {\n\t\t\t\tdescriptors[ key ] = Object.getOwnPropertyDescriptor(source, key);\n\t\t\t\treturn descriptors;\n\t\t\t},\n\t\t\t{}\n\t\t)\n\t);\n  });\n  return target;\n}\n\n/* The rebased functions we need to decorate compose constructors with */\nconst doExtend = rebase(extend);\nconst doMixin = rebase(mixin);\nconst doOverlay = rebase(overlay);\nconst doAspect = rebase(aspect);\n\n/**\n * A convenience function to decorate compose class constructors\n * @param {any} base The target constructor\n */\nfunction stamp(base: any): void {\n   base.extend = doExtend;\n   base.mixin = doMixin;\n   base.overlay = doOverlay;\n   base.from = doFrom;\n   base.before = doBefore;\n   base.after = doAfter;\n   base.around = doAround;\n   base.aspect = doAspect;\n}\n\n/**\n * Take a compose constructor and clone it\n * @param  {ComposeFactory<O, T>} base The base to clone\n * @return {ComposeFactory<O, T>}      The cloned constructor function\n */\nfunction cloneFactory<O, T>(base?: ComposeFactory<O, T>): ComposeFactory<O, T>;\nfunction cloneFactory(base?: any): any {\n\tfunction factory(...args: any[]): any {\n\t\tif (this && this.constructor === factory) {\n\t\t\tthrow new SyntaxError('Factories cannot be called with \"new\".');\n\t\t}\n\t\tconst instance = Object.create(factory.prototype);\n\t\targs.unshift(instance);\n\t\tinitFnMap.get(factory).forEach(fn => fn.apply(null, args));\n\t\treturn instance;\n\t}\n\n\tif (base) {\n\t\tcopyProperties(factory.prototype, base.prototype);\n\t\tinitFnMap.set(factory, [].concat(initFnMap.get(base)));\n\t}\n\telse {\n\t\tinitFnMap.set(factory, []);\n\t}\n\tfactory.prototype.constructor = factory;\n\tstamp(factory);\n\tObject.freeze(factory);\n\n\treturn factory;\n}\n\n/**\n * Takes any init functions from source and concats them to base\n * @param target The compose factory to copy the init functions onto\n * @param source The ComposeFactory to copy the init functions from\n */\nfunction concatInitFn<O, T, P, S>(target: ComposeFactory<O, T>, source: ComposeFactory<P, S>): void {\n\tconst sourceInitFns = initFnMap.get(source);\n\n\t/* making sure only unique functions get added */\n\tconst targetInitFns = initFnMap.get(target).filter((fn) => {\n\t\treturn sourceInitFns.indexOf(fn) < 0;\n\t});\n\n\t/* now prepend the source init functions to the unique init functions for the target */\n\tinitFnMap.set(target, sourceInitFns.concat(targetInitFns));\n}\n\n/**\n * A custom type guard that determines if the value is a ComposeFactory\n * @param   value The target to check\n * @returns       Return true if it is a ComposeFactory, otherwise false\n */\nexport function isComposeFactory(value: any): value is ComposeFactory< any, any > {\n\treturn Boolean(initFnMap.get(value));\n}\n\n/* General Interfaces */\n\nexport interface GenericClass<T> {\n\tnew (...args: any[]): T;\n\tprototype: T;\n}\n\nexport interface ComposeInitializationFunction<O, T> {\n\t(instance: T, options?: O): void;\n}\n\n/* Extension API */\nexport interface ComposeFactory<K, A> {\n\textend<U>(extension: U | GenericClass<U>): ComposeFactory<K, A & U>;\n\textend<L, U>(extension: ComposeFactory<L, U>): ComposeFactory<K & L, A & U>;\n}\n\nexport interface Compose {\n\textend<O, A, B>(base: ComposeFactory<O, A>, extension: B | GenericClass<B>): ComposeFactory<O, A & B>;\n\textend<O, A, P, B>(base: ComposeFactory<O, A>, extension: ComposeFactory<P, B>): ComposeFactory<O & P, A & B>;\n}\n\nfunction extend<O, A, P, B>(base: ComposeFactory<O, A>, extension: ComposeFactory<P, B>): ComposeFactory<O & P, A & B>;\nfunction extend<O>(base: ComposeFactory<O, any>, extension: any): ComposeFactory<O, any> {\n\tbase = cloneFactory(base);\n\tcopyProperties(base.prototype, typeof extension === 'function' ? extension.prototype : extension);\n\treturn base;\n}\n\n/* Overlay API */\nexport interface OverlayFunction<T> {\n\t(proto: T): void;\n}\n\nexport interface ComposeFactory<K, A> {\n\t overlay(overlayFunction: OverlayFunction<A>): ComposeFactory<K, A>;\n}\n\nexport interface Compose {\n\toverlay<O, A>(base: ComposeFactory<O, A>, overlayFunction: OverlayFunction<A>): ComposeFactory<O, A>;\n}\n\nfunction overlay<O, A>(base: ComposeFactory<O, A>, overlayFunction: OverlayFunction<A>): ComposeFactory<O, A> {\n\tbase = cloneFactory(base);\n\toverlayFunction(base.prototype);\n\treturn base;\n}\n\n/* AOP/Inheritance API */\n\nexport interface AspectAdvice {\n\tbefore?: { [method: string]: BeforeAdvice };\n\tafter?: { [method: string]: AfterAdvice<any> };\n\taround?: { [method: string]: AroundAdvice<any> };\n}\n\n/* Mixin API */\nexport interface ComposeMixin<A, O, P, T> {\n\tmixin?: GenericClass<P> | P | ComposeFactory<T, P>;\n\tinitializer?: ComposeInitializationFunction<O, P & A>;\n\taspectAdvice?: AspectAdvice;\n}\n\nexport interface ComposeFactory<K, A> {\n\tmixin<L, B, T>(mixin: ComposeMixin<A, T, B, L>): ComposeFactory<K & L, A & B>;\n}\n\nexport interface Compose {\n\tmixin<K, L, A, B, T>(\n\t\tbase: ComposeFactory<K, A>,\n\t\tmixin: ComposeMixin<A, T, B, L>\n\t): ComposeFactory<K & L, A & B>;\n}\n\nfunction mixin<K, L, A, B, T>(\n\tbase: ComposeFactory<K, A>,\n\tmixin: ComposeMixin<A, T, B, L>\n): ComposeFactory<K & L, A & B>;\n\nfunction mixin<A>(base: ComposeFactory<A, any>, mixin: any): ComposeFactory<A, any> {\n\tbase = cloneFactory(base);\n\tconst baseInitFns = initFnMap.get(base);\n\tif (mixin.mixin) {\n\t\tlet mixinFactory = isComposeFactory(mixin.mixin) ? mixin.mixin : create(mixin.mixin);\n\t\tif (mixin.initializer) {\n\t\t\tif (baseInitFns.indexOf(mixin.initializer) < 0) {\n\t\t\t\tbaseInitFns.unshift(mixin.initializer);\n\t\t\t}\n\t\t}\n\t\tconcatInitFn(base, mixinFactory);\n\t\tcopyProperties(base.prototype, mixinFactory.prototype);\n\t} else if (mixin.initializer) {\n\t\tif (baseInitFns.indexOf(mixin.initializer) < 0) {\n\t\t\tbaseInitFns.unshift(mixin.initializer);\n\t\t}\n\t}\n\tif (mixin.aspectAdvice) {\n\t\tbase = aspect(base, mixin.aspectAdvice);\n\t}\n\n\treturn base;\n}\n\nexport interface GenericFunction<T> {\n\t(...args: any[]): T;\n}\n\nexport interface ComposeFactory<K, A> {\n\tfrom(base: GenericClass<any>, method: string): ComposeFactory<K, A>;\n\tfrom(base: ComposeFactory<any, any>, method: string): ComposeFactory<K, A>;\n\n\tbefore(method: string, advice: BeforeAdvice): ComposeFactory<K, A>;\n\tafter<P>(method: string, advice: AfterAdvice<P>): ComposeFactory<K, A>;\n\taround<P>(method: string, advice: AroundAdvice<P>): ComposeFactory<K, A>;\n\n\taspect(advice: AspectAdvice): ComposeFactory<K, A>;\n}\n\nexport interface Compose {\n\tfrom<T extends Function>(base: GenericClass<any>, method: string): T;\n\tfrom<T extends Function>(base: ComposeFactory<any, any>, method: string): T;\n\n\tbefore<T>(base: GenericClass<any>, method: string, advice: BeforeAdvice): GenericFunction<T>;\n\tbefore<T>(base: ComposeFactory<any, any>, method: string, advice: BeforeAdvice): GenericFunction<T>;\n\tbefore<T>(method: GenericFunction<T>, advice: BeforeAdvice): GenericFunction<T>;\n\n\tafter<T>(base: GenericClass<any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\n\tafter<T>(base: ComposeFactory<any, any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\n\tafter<T>(method: GenericFunction<T>, advice: AfterAdvice<T>): GenericFunction<T>;\n\n\taround<T>(base: GenericClass<any>, method: string, advice: AroundAdvice<T>): GenericFunction<T>;\n\taround<T>(base: ComposeFactory<any, any>, method: string, advice: AroundAdvice<T>): GenericFunction<T>;\n\taround<T>(method: GenericFunction<T>, advice: AroundAdvice<T>): GenericFunction<T>;\n\n\taspect<O, A>(base: ComposeFactory<O, A>, advice: AspectAdvice): ComposeFactory<O, A>;\n}\n\nfunction from<T extends Function>(base: GenericClass<any>, method: string): T;\nfunction from<T extends Function>(base: ComposeFactory<any, any>, method: string): T;\nfunction from<T extends Function>(base: any, method: string): T {\n\treturn base.prototype[method];\n}\n\nfunction doFrom<O, T>(base: GenericClass<any>, method: string): ComposeFactory<O, T>;\nfunction doFrom<O, T>(base: ComposeFactory<any, any>, method: string): ComposeFactory<O, T>;\nfunction doFrom(base: any, method: string): ComposeFactory<any, any> {\n\tconst clone = cloneFactory(this);\n\t(<any> clone.prototype)[method] = base.prototype[method];\n\treturn clone;\n}\n\nfunction before<T>(base: GenericClass<any>, method: string, advice: BeforeAdvice): GenericFunction<T>;\nfunction before<T>(base: ComposeFactory<any, any>, method: string, advice: BeforeAdvice): GenericFunction<T>;\nfunction before<T>(method: GenericFunction<T>, advice: BeforeAdvice): GenericFunction<T>;\nfunction before(...args: any[]): GenericFunction<any> {\n\tlet base: GenericFunction<any>;\n\tlet method: string | GenericFunction<any>;\n\tlet advice: BeforeAdvice;\n\tif (args.length >= 3) {\n\t\t[ base, method, advice ] = args;\n\t\tmethod = base.prototype[<string> method];\n\t}\n\telse {\n\t\t[ method, advice ] = args;\n\t}\n\treturn aspectBefore(<GenericFunction<any>> method, advice);\n}\n\nfunction doBefore<O, T>(method: string, advice: BeforeAdvice): ComposeFactory<O, T> {\n\tconst clone = cloneFactory(this);\n\t(<any> clone.prototype)[method] = aspectBefore((<any> clone.prototype)[method], advice);\n\treturn <ComposeFactory<O, T>> clone;\n}\n\nfunction after<T>(base: GenericClass<any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\nfunction after<T>(base: ComposeFactory<any, any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\nfunction after<T>(method: GenericFunction<T>, advice: AfterAdvice<T>): GenericFunction<T>;\nfunction after(...args: any[]): GenericFunction<any> {\n\tlet base: GenericFunction<any>;\n\tlet method: string | GenericFunction<any>;\n\tlet advice: AfterAdvice<any>;\n\tif (args.length >= 3) {\n\t\t[ base, method, advice ] = args;\n\t\tmethod = base.prototype[<string> method];\n\t}\n\telse {\n\t\t[ method, advice ] = args;\n\t}\n\treturn aspectAfter(<GenericFunction<any>> method, advice);\n}\n\nfunction doAfter<O, P, T>(method: string, advice: AfterAdvice<P>): ComposeFactory<O, T> {\n\tconst clone = cloneFactory(this);\n\t(<any> clone.prototype)[method] = aspectAfter((<any> clone.prototype)[method], advice);\n\treturn <ComposeFactory <O, T>> clone;\n}\n\nfunction around<T>(base: GenericClass<any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\nfunction around<T>(base: ComposeFactory<any, any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\nfunction around<T>(method: GenericFunction<T>, advice: AroundAdvice<T>): GenericFunction<T>;\nfunction around(...args: any[]): GenericFunction<any> {\n\tlet base: GenericFunction<any>;\n\tlet method: string | GenericFunction<any>;\n\tlet advice: AfterAdvice<any>;\n\tif (args.length >= 3) {\n\t\t[ base, method, advice ] = args;\n\t\tmethod = base.prototype[<string> method];\n\t}\n\telse {\n\t\t[ method, advice ] = args;\n\t}\n\treturn aspectAround(<GenericFunction<any>> method, advice);\n}\n\nfunction doAround<O, P, T>(method: string, advice: AroundAdvice<P>): ComposeFactory<O, T> {\n\tconst clone = cloneFactory(this);\n\t(<any> clone.prototype)[method] = aspectAround((<any> clone.prototype)[method], advice);\n\treturn <ComposeFactory <O, T>> clone;\n}\n\nfunction aspect<O, A>(base: ComposeFactory<O, A>, advice: AspectAdvice): ComposeFactory<O, A> {\n\tconst clone = cloneFactory(base);\n\n\tfunction mapAdvice(adviceHash: { [method: string ]: Function }, advisor: Function): void {\n\t\tfor (let key in adviceHash) {\n\t\t\tif (key in clone.prototype) {\n\t\t\t\t(<any> clone.prototype)[key] = advisor((<any> clone.prototype)[key], adviceHash[key]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new Error('Trying to advise non-existing method: \"' + key + '\"');\n\t\t\t}\n\t\t}\n\t}\n\n\tif (advice.before) {\n\t\tmapAdvice(advice.before, before);\n\t}\n\tif (advice.after) {\n\t\tmapAdvice(advice.after, after);\n\t}\n\tif (advice.around) {\n\t\tmapAdvice(advice.around, around);\n\t}\n\treturn clone;\n}\n\n/* Creation API */\nexport interface ComposeFactory<K, A> {\n\t(options?: K): A;\n\tprototype: A;\n}\n\nexport interface Compose {\n\t<O, A>(base: GenericClass<A>, initFunction?: ComposeInitializationFunction<O, A>): ComposeFactory<O, A>;\n\t<O, A, P>(base: ComposeFactory<O, A>, initFunction?: ComposeInitializationFunction<P, A>): ComposeFactory<O & P, A>;\n\t<O, A>(base: A, initFunction?: ComposeInitializationFunction<O, A>): ComposeFactory<O, A>;\n\tcreate<O, A>(base: GenericClass<A>, initFunction?: ComposeInitializationFunction<O, A>): ComposeFactory<O, A>;\n\tcreate<O, A, P>(base: ComposeFactory<O, A>, initFunction?: ComposeInitializationFunction<P, A>): ComposeFactory<O & P, A>;\n\tcreate<O, A>(base: A, initFunction?: ComposeInitializationFunction<O, A>): ComposeFactory<O, A>;\n}\n\nfunction create<O, A>(base: GenericClass<A>, initFunction?: ComposeInitializationFunction<O, A>): ComposeFactory<O, A>;\nfunction create<O, A, P>(base: ComposeFactory<O, A>, initFunction?: ComposeInitializationFunction<P, A>): ComposeFactory<O & P, A>;\nfunction create<O, A>(base: A, initFunction?: ComposeInitializationFunction<O, A>): ComposeFactory<O, A>;\nfunction create<O>(base: any, initFunction?: ComposeInitializationFunction<O, any>): any {\n\tconst factory = cloneFactory();\n\tif (initFunction) {\n\t\tinitFnMap.get(factory).push(initFunction);\n\t}\n\n\t/* mixin the base into the prototype */\n\tcopyProperties(factory.prototype, typeof base === 'function' ? base.prototype : base);\n\n   /* return the new constructor */\n   return factory;\n}\n\n/* Generate compose */\n(<Compose> create).create = create;\n(<Compose> create).extend = extend;\n(<Compose> create).mixin = mixin;\n(<Compose> create).overlay = overlay;\n(<Compose> create).from = from;\n(<Compose> create).before = before;\n(<Compose> create).after = after;\n(<Compose> create).around = around;\n(<Compose> create).aspect = aspect;\n\nconst compose: Compose = <Compose> create;\n\nexport default compose;\n"]}