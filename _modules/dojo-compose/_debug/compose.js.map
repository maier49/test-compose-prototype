{"version":3,"file":"compose.js","sourceRoot":"","sources":["compose.ts"],"names":["rebase","copyProperties","stamp","cloneFactory","cloneFactory.factory","concatInitFn","isComposeFactory","extend","overlay","mixin","from","doFrom","before","doBefore","after","doAfter","around","doAround","aspect","aspect.mapAdvice","create"],"mappings":"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","sourcesContent":["import WeakMap from 'dojo-core/WeakMap';\r\nimport {\r\n\tbefore as aspectBefore,\r\n\tafter as aspectAfter,\r\n\taround as aspectAround,\r\n\tBeforeAdvice,\r\n\tAfterAdvice,\r\n\tAroundAdvice\r\n} from './aspect';\r\n\r\n/* A weakmap that will store initialization functions for compose constructors */\r\nconst initFnMap = new WeakMap<Function, ComposeInitializationFunction<any>[]>();\r\n\r\n/**\r\n * A helper funtion to return a function that is rebased\r\n * @param  {Function} fn The function to be rebased\r\n * @return {Function}    The rebased function\r\n */\r\nfunction rebase(fn: Function): Function {\r\n   return function(...args: any[]) {\r\n\t   return fn.apply(this, [ this ].concat(args));\r\n   };\r\n}\r\n\r\n/**\r\n * A helper function that copies own properties and their descriptors\r\n * from one or more sources to a target object. Includes non-enumerable properties\r\n */\r\nfunction copyProperties(target: {}, ...sources: {}[]) {\r\n  sources.forEach(source => {\r\n    Object.defineProperties(\r\n\t\ttarget,\r\n\t\tObject.getOwnPropertyNames(source).reduce(\r\n\t\t\t(descriptors: { [ index: string ]: any }, key: string) => {\r\n\t\t\t\tdescriptors[ key ] = Object.getOwnPropertyDescriptor(source, key);\r\n\t\t\t\treturn descriptors;\r\n\t\t\t},\r\n\t\t\t{}\r\n\t\t)\r\n\t);\r\n  });\r\n  return target;\r\n}\r\n\r\n/* The rebased functions we need to decorate compose constructors with */\r\nconst doExtend = rebase(extend);\r\nconst doMixin = rebase(mixin);\r\nconst doOverlay = rebase(overlay);\r\nconst doAspect = rebase(aspect);\r\n\r\n/**\r\n * A convenience function to decorate compose class constructors\r\n * @param {any} base The target constructor\r\n */\r\nfunction stamp(base: any): void {\r\n   base.extend = doExtend;\r\n   base.mixin = doMixin;\r\n   base.overlay = doOverlay;\r\n   base.from = doFrom;\r\n   base.before = doBefore;\r\n   base.after = doAfter;\r\n   base.around = doAround;\r\n   base.aspect = doAspect;\r\n}\r\n\r\n/**\r\n * Take a compose constructor and clone it\r\n * @param  {ComposeFactory<O, T>} base The base to clone\r\n * @return {ComposeFactory<O, T>}      The cloned constructor function\r\n */\r\nfunction cloneFactory<O, T>(base?: ComposeFactory<O, T>): ComposeFactory<O, T>;\r\nfunction cloneFactory(base?: any): any {\r\n\tfunction factory(...args: any[]): any {\r\n\t\tif (this && this.constructor === factory) {\r\n\t\t\tthrow new SyntaxError('Factories cannot be called with \"new\".');\r\n\t\t}\r\n\t\tconst instance = Object.create(factory.prototype);\r\n\t\tinitFnMap.get(factory).forEach(fn => fn.apply(instance, args));\r\n\t\treturn instance;\r\n\t}\r\n\r\n\tif (base) {\r\n\t\tcopyProperties(factory.prototype, base.prototype);\r\n\t\tinitFnMap.set(factory, [].concat(initFnMap.get(base)));\r\n\t}\r\n\telse {\r\n\t\tinitFnMap.set(factory, []);\r\n\t}\r\n\tfactory.prototype.constructor = factory;\r\n\tstamp(factory);\r\n\tObject.freeze(factory);\r\n\r\n\treturn factory;\r\n}\r\n\r\n/**\r\n * Takes any init functions from source and concats them to base\r\n * @param target The compose factory to copy the init functions onto\r\n * @param source The ComposeFactory to copy the init functions from\r\n */\r\nfunction concatInitFn<O, T, P, S>(target: ComposeFactory<O, T>, source: ComposeFactory<P, S>): void {\r\n\tconst initFn = initFnMap.get(target);\r\n\t/* making sure only unique functions get added */\r\n\tinitFnMap.get(source).forEach((item) => {\r\n\t\tif (initFn.indexOf(item) < 0) {\r\n\t\t\tinitFn.push(item);\r\n\t\t}\r\n\t});\r\n}\r\n\r\n/**\r\n * A custom type guard that determines if the value is a ComposeFactory\r\n * @param   value The target to check\r\n * @returns       Return true if it is a ComposeFactory, otherwise false\r\n */\r\nexport function isComposeFactory(value: any): value is ComposeFactory< any, any > {\r\n\treturn Boolean(initFnMap.get(value));\r\n}\r\n\r\n/* General Interfaces */\r\n\r\nexport interface GenericClass<T> {\r\n\tnew (...args: any[]): T;\r\n\tprototype: T;\r\n}\r\n\r\nexport interface ComposeInitializationFunction<O> {\r\n\t(options?: O): void;\r\n}\r\n\r\n/* Extension API */\r\nexport interface ComposeFactory<O, T> {\r\n\textend<U>(extension: U): ComposeFactory<O, T & U>;\r\n}\r\n\r\nexport interface Compose {\r\n\textend<O, A, B>(base: ComposeFactory<O, A>, extension: B): ComposeFactory<O, A & B>;\r\n}\r\n\r\nfunction extend<O, A, B>(base: ComposeFactory<O, A>, extension: B): ComposeFactory<O, A & B>;\r\nfunction extend<O>(base: ComposeFactory<O, any>, extension: any): ComposeFactory<O, any> {\r\n\tbase = cloneFactory(base);\r\n\tcopyProperties(base.prototype, extension);\r\n\treturn base;\r\n}\r\n\r\n/* Overlay API */\r\nexport interface OverlayFunction<T> {\r\n\t(proto: T): void;\r\n}\r\n\r\nexport interface ComposeFactory<O, T> {\r\n\t overlay(overlayFunction: OverlayFunction<T>): ComposeFactory<O, T>;\r\n}\r\n\r\nexport interface Compose {\r\n\toverlay<O, A>(base: ComposeFactory<O, A>, overlayFunction: OverlayFunction<A>): ComposeFactory<O, A>;\r\n}\r\n\r\nfunction overlay<O, A>(base: ComposeFactory<O, A>, overlayFunction: OverlayFunction<A>): ComposeFactory<O, A> {\r\n\tbase = cloneFactory(base);\r\n\toverlayFunction(base.prototype);\r\n\treturn base;\r\n}\r\n\r\n/* AOP/Inheritance API */\r\n\r\nexport interface AspectAdvice {\r\n\tbefore?: { [method: string]: BeforeAdvice };\r\n\tafter?: { [method: string]: AfterAdvice<any> };\r\n\taround?: { [method: string]: AroundAdvice<any> };\r\n}\r\n\r\n/* Mixin API */\r\nexport interface ComposeClassMixin<O, P> {\r\n\tbase?: GenericClass<O>;\r\n\tinitializer?: ComposeInitializationFunction<P>;\r\n\taspectAdvice?: AspectAdvice;\r\n}\r\n\r\nexport interface ComposeFactoryMixin<O, P, T> {\r\n\tbase?: ComposeFactory<O, T>;\r\n\tinitializer?: ComposeInitializationFunction<P>;\r\n\taspectAdvice?: AspectAdvice;\r\n}\r\n\r\nexport interface ComposeFactory<O, T> {\r\n\tmixin<P, U, V>(mixin: ComposeClassMixin<U, V>): ComposeFactory<O, T & U>;\r\n\tmixin<P, U, V>(mixin: ComposeFactoryMixin<P, V, U>): ComposeFactory<O & P, T & U>;\r\n}\r\n\r\nexport interface Compose {\r\n\tmixin<O, A, B, C>(base: ComposeFactory<O, A>, mixin: ComposeClassMixin<B, C>): ComposeFactory<O, A & B>;\r\n\tmixin<O, P, A, B, C>(base: ComposeFactory<O, A>, mixin: ComposeFactoryMixin<P, C, B>): ComposeFactory<O & P, A & B>;\r\n}\r\n\r\nfunction mixin<A, B, O, P>(base: ComposeFactory<A, O>, mixin: ComposeClassMixin<B, P>): ComposeFactory<A, O & P>;\r\nfunction mixin<A, B, O, P, T>(base: ComposeFactory<A, O>, mixin: ComposeFactoryMixin<B, P, T>): ComposeFactory<A & B, O & P>;\r\nfunction mixin<A>(base: ComposeFactory<A, any>, mixin: any): ComposeFactory<A, any> {\r\n\tbase = cloneFactory(base);\r\n\tif (mixin.base) {\r\n\t\tlet mixinFactory = isComposeFactory(mixin.base) ? mixin.base : create(mixin.base);\r\n\t\tif (mixin.initializer) {\r\n\t\t\tinitFnMap.get(mixinFactory).push(mixin.initializer);\r\n\t\t}\r\n\t\tconcatInitFn(base, mixinFactory);\r\n\t\tcopyProperties(base.prototype, mixinFactory.prototype);\r\n\t} else if (mixin.initializer) {\r\n\t\tbase = create(base, mixin.initializer);\r\n\t}\r\n\tif (mixin.aspectAdvice) {\r\n\t\tbase = aspect(base, mixin.aspectAdvice);\r\n\t}\r\n\treturn base;\r\n}\r\n\r\nexport interface GenericFunction<T> {\r\n\t(...args: any[]): T;\r\n}\r\n\r\nexport interface ComposeFactory<O, T> {\r\n\tfrom(base: GenericClass<any>, method: string): ComposeFactory<O, T>;\r\n\tfrom(base: ComposeFactory<any, any>, method: string): ComposeFactory<O, T>;\r\n\r\n\tbefore(method: string, advice: BeforeAdvice): ComposeFactory<O, T>;\r\n\tafter<P>(method: string, advice: AfterAdvice<P>): ComposeFactory<O, T>;\r\n\taround<P>(method: string, advice: AroundAdvice<P>): ComposeFactory<O, T>;\r\n\r\n\taspect(advice: AspectAdvice): ComposeFactory<O, T>;\r\n}\r\n\r\nexport interface Compose {\r\n\tfrom<T extends Function>(base: GenericClass<any>, method: string): T;\r\n\tfrom<T extends Function>(base: ComposeFactory<any, any>, method: string): T;\r\n\r\n\tbefore<T>(base: GenericClass<any>, method: string, advice: BeforeAdvice): GenericFunction<T>;\r\n\tbefore<T>(base: ComposeFactory<any, any>, method: string, advice: BeforeAdvice): GenericFunction<T>;\r\n\tbefore<T>(method: GenericFunction<T>, advice: BeforeAdvice): GenericFunction<T>;\r\n\r\n\tafter<T>(base: GenericClass<any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\r\n\tafter<T>(base: ComposeFactory<any, any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\r\n\tafter<T>(method: GenericFunction<T>, advice: AfterAdvice<T>): GenericFunction<T>;\r\n\r\n\taround<T>(base: GenericClass<any>, method: string, advice: AroundAdvice<T>): GenericFunction<T>;\r\n\taround<T>(base: ComposeFactory<any, any>, method: string, advice: AroundAdvice<T>): GenericFunction<T>;\r\n\taround<T>(method: GenericFunction<T>, advice: AroundAdvice<T>): GenericFunction<T>;\r\n\r\n\taspect<O, A>(base: ComposeFactory<O, A>, advice: AspectAdvice): ComposeFactory<O, A>;\r\n}\r\n\r\nfunction from<T extends Function>(base: GenericClass<any>, method: string): T;\r\nfunction from<T extends Function>(base: ComposeFactory<any, any>, method: string): T;\r\nfunction from<T extends Function>(base: any, method: string): T {\r\n\treturn base.prototype[method];\r\n}\r\n\r\nfunction doFrom<O, T>(base: GenericClass<any>, method: string): ComposeFactory<O, T>;\r\nfunction doFrom<O, T>(base: ComposeFactory<any, any>, method: string): ComposeFactory<O, T>;\r\nfunction doFrom(base: any, method: string): ComposeFactory<any, any> {\r\n\tconst clone = cloneFactory(this);\r\n\t(<any> clone.prototype)[method] = base.prototype[method];\r\n\treturn clone;\r\n}\r\n\r\nfunction before<T>(base: GenericClass<any>, method: string, advice: BeforeAdvice): GenericFunction<T>;\r\nfunction before<T>(base: ComposeFactory<any, any>, method: string, advice: BeforeAdvice): GenericFunction<T>;\r\nfunction before<T>(method: GenericFunction<T>, advice: BeforeAdvice): GenericFunction<T>;\r\nfunction before(...args: any[]): GenericFunction<any> {\r\n\tlet base: GenericFunction<any>;\r\n\tlet method: string | GenericFunction<any>;\r\n\tlet advice: BeforeAdvice;\r\n\tif (args.length >= 3) {\r\n\t\t[ base, method, advice ] = args;\r\n\t\tmethod = base.prototype[<string> method];\r\n\t}\r\n\telse {\r\n\t\t[ method, advice ] = args;\r\n\t}\r\n\treturn aspectBefore(<GenericFunction<any>> method, advice);\r\n}\r\n\r\nfunction doBefore<O, T>(method: string, advice: BeforeAdvice): ComposeFactory<O, T> {\r\n\tconst clone = cloneFactory(this);\r\n\t(<any> clone.prototype)[method] = aspectBefore((<any> clone.prototype)[method], advice);\r\n\treturn <ComposeFactory<O, T>> clone;\r\n}\r\n\r\nfunction after<T>(base: GenericClass<any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\r\nfunction after<T>(base: ComposeFactory<any, any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\r\nfunction after<T>(method: GenericFunction<T>, advice: AfterAdvice<T>): GenericFunction<T>;\r\nfunction after(...args: any[]): GenericFunction<any> {\r\n\tlet base: GenericFunction<any>;\r\n\tlet method: string | GenericFunction<any>;\r\n\tlet advice: AfterAdvice<any>;\r\n\tif (args.length >= 3) {\r\n\t\t[ base, method, advice ] = args;\r\n\t\tmethod = base.prototype[<string> method];\r\n\t}\r\n\telse {\r\n\t\t[ method, advice ] = args;\r\n\t}\r\n\treturn aspectAfter(<GenericFunction<any>> method, advice);\r\n}\r\n\r\nfunction doAfter<O, P, T>(method: string, advice: AfterAdvice<P>): ComposeFactory<O, T> {\r\n\tconst clone = cloneFactory(this);\r\n\t(<any> clone.prototype)[method] = aspectAfter((<any> clone.prototype)[method], advice);\r\n\treturn <ComposeFactory <O, T>> clone;\r\n}\r\n\r\nfunction around<T>(base: GenericClass<any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\r\nfunction around<T>(base: ComposeFactory<any, any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\r\nfunction around<T>(method: GenericFunction<T>, advice: AroundAdvice<T>): GenericFunction<T>;\r\nfunction around(...args: any[]): GenericFunction<any> {\r\n\tlet base: GenericFunction<any>;\r\n\tlet method: string | GenericFunction<any>;\r\n\tlet advice: AfterAdvice<any>;\r\n\tif (args.length >= 3) {\r\n\t\t[ base, method, advice ] = args;\r\n\t\tmethod = base.prototype[<string> method];\r\n\t}\r\n\telse {\r\n\t\t[ method, advice ] = args;\r\n\t}\r\n\treturn aspectAround(<GenericFunction<any>> method, advice);\r\n}\r\n\r\nfunction doAround<O, P, T>(method: string, advice: AroundAdvice<P>): ComposeFactory<O, T> {\r\n\tconst clone = cloneFactory(this);\r\n\t(<any> clone.prototype)[method] = aspectAround((<any> clone.prototype)[method], advice);\r\n\treturn <ComposeFactory <O, T>> clone;\r\n}\r\n\r\nfunction aspect<O, A>(base: ComposeFactory<O, A>, advice: AspectAdvice): ComposeFactory<O, A> {\r\n\tconst clone = cloneFactory(base);\r\n\r\n\tfunction mapAdvice(adviceHash: { [method: string ]: Function }, advisor: Function): void {\r\n\t\tfor (let key in adviceHash) {\r\n\t\t\tif (key in clone.prototype) {\r\n\t\t\t\t(<any> clone.prototype)[key] = advisor((<any> clone.prototype)[key], adviceHash[key]);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthrow new Error('Trying to advise non-existing method: \"' + key + '\"');\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (advice.before) {\r\n\t\tmapAdvice(advice.before, before);\r\n\t}\r\n\tif (advice.after) {\r\n\t\tmapAdvice(advice.after, after);\r\n\t}\r\n\tif (advice.around) {\r\n\t\tmapAdvice(advice.around, around);\r\n\t}\r\n\treturn clone;\r\n}\r\n\r\n/* Creation API */\r\nexport interface ComposeFactory<O, T> {\r\n\t(options?: O): T;\r\n\tprototype: T;\r\n}\r\n\r\nexport interface Compose {\r\n\t<O, A>(base: GenericClass<A>, initFunction?: ComposeInitializationFunction<O>): ComposeFactory<O, A>;\r\n\t<O, A, P>(base: ComposeFactory<O, A>, initFunction?: ComposeInitializationFunction<P>): ComposeFactory<O & P, A>;\r\n\t<O, A>(base: A, initFunction?: ComposeInitializationFunction<O>): ComposeFactory<O, A>;\r\n\tcreate<O, A>(base: GenericClass<A>, initFunction?: ComposeInitializationFunction<O>): ComposeFactory<O, A>;\r\n\tcreate<O, A, P>(base: ComposeFactory<O, A>, initFunction?: ComposeInitializationFunction<P>): ComposeFactory<O & P, A>;\r\n\tcreate<O, A>(base: A, initFunction?: ComposeInitializationFunction<O>): ComposeFactory<O, A>;\r\n}\r\n\r\nfunction create<O, A>(base: GenericClass<A>, initFunction?: ComposeInitializationFunction<O>): ComposeFactory<O, A>;\r\nfunction create<O, A, P>(base: ComposeFactory<O, A>, initFunction?: ComposeInitializationFunction<P>): ComposeFactory<O & P, A>;\r\nfunction create<O, A>(base: A, initFunction?: ComposeInitializationFunction<O>): ComposeFactory<O, A>;\r\nfunction create<O>(base: any, initFunction?: ComposeInitializationFunction<O>): any {\r\n\tconst factory = cloneFactory();\r\n\tif (initFunction) {\r\n\t\tinitFnMap.get(factory).push(initFunction);\r\n\t}\r\n\r\n\t/* mixin the base into the prototype */\r\n\tcopyProperties(factory.prototype, typeof base === 'function' ? base.prototype : base);\r\n\r\n   /* return the new constructor */\r\n   return factory;\r\n}\r\n\r\n/* Generate compose */\r\n(<Compose> create).create = create;\r\n(<Compose> create).extend = extend;\r\n(<Compose> create).mixin = mixin;\r\n(<Compose> create).overlay = overlay;\r\n(<Compose> create).from = from;\r\n(<Compose> create).before = before;\r\n(<Compose> create).after = after;\r\n(<Compose> create).around = around;\r\n(<Compose> create).aspect = aspect;\r\n\r\nconst compose: Compose = <Compose> create;\r\n\r\nexport default compose;\r\n"]}